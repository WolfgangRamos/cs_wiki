<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Prädikatenlogik</a>
<ul>
<li><a href="#sec-1-1">1.1. Sorten</a></li>
<li><a href="#sec-1-2">1.2. Sortenmenge</a></li>
<li><a href="#sec-1-3">1.3. sortierte Menge</a></li>
<li><a href="#sec-1-4">1.4. Algebraische Signatur</a>
<ul>
<li><a href="#sec-1-4-1">1.4.1. Terme</a>
<ul>
<li><a href="#sec-1-4-1-1">1.4.1.1. Semantik</a></li>
</ul>
</li>
<li><a href="#sec-1-4-2">1.4.2. Gleichungen</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. Relationale Signatur</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. Homomorphismus</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6. Struktur</a></li>
<li><a href="#sec-1-7">1.7. Formeln</a>
<ul>
<li><a href="#sec-1-7-1">1.7.1. <span class="todo TODO">TODO</span> Variablen spezifizieren</a></li>
<li><a href="#sec-1-7-2">1.7.2. Koinzidenzlemma</a></li>
</ul>
</li>
<li><a href="#sec-1-8">1.8. <span class="todo TODO">TODO</span> Anfrage</a></li>
<li><a href="#sec-1-9">1.9. Substitution</a>
<ul>
<li><a href="#sec-1-9-1">1.9.1. Ersetzung von</a></li>
<li><a href="#sec-1-9-2">1.9.2. Termsubstitution</a></li>
<li><a href="#sec-1-9-3">1.9.3. Termsubstitution auf Formeln</a></li>
</ul>
</li>
<li><a href="#sec-1-10">1.10. Quantoren</a></li>
<li><a href="#sec-1-11">1.11. <span class="todo TODO">TODO</span> Pränexe Normalform</a></li>
<li><a href="#sec-1-12">1.12. <span class="todo TODO">TODO</span> Skolemisierung</a></li>
<li><a href="#sec-1-13">1.13. <span class="todo TODO">TODO</span> Erfüllbarkeitsreduktion</a></li>
<li><a href="#sec-1-14">1.14. <span class="todo TODO">TODO</span> Erfüllarkeitstests</a></li>
<li><a href="#sec-1-15">1.15. <span class="todo TODO">TODO</span> Termsturkuren und Modelle</a></li>
<li><a href="#sec-1-16">1.16. Elimieren von Gleichheit</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Prädikatenlogik</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Sorten</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Sorten kann man sich wie Datentypen von Programmiersprachen
vorstellen. Sorten schreiben wir mit großem Anfangsbuchstaben, z.B.
\(\text{Number}\).
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Sortenmenge</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Eine nichtleere Menge von Sorten \(S = \{s_0, s_1,\dots\}\) heißt <i>Sortenmenge</i>.
Die Elemente von \(S\) heißen <i>Sorten</i>.
</p>

<p>
Enthält \(S\) lediglich ein Element, so spricht man von <b>Einsortigkeit</b>.
</p>

<p>
Mengenoperationen auf sortierten Mengen zur selben Sortenmenge werden
sortenweise auf die Elemente der sortierten Mengen übertragen, d.h. es
gilt z.B.:
</p>

<p>
\(\{M_s\}_{s\in S} \cap \{N_s\}_{s \in S} := \{M_s \cap N_s\}_{s\in S}\)
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> sortierte Menge</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Eine \(S\)-sortiert Menge \(M\) ist eine Menge von nichtleeren Mengen, in
der jede nicht-leeren Menge einer Sorte der Sortenmenge \(S\) zugeordent
werden kann. Wir sagen die Elemtente von \(M\) können mit den Elementen
von \(S\) <i>indiziert</i> werden und schreiben \(M = \{M_s\}_{s\in S}\), wobei
\(M_s \neq \emptyset\) für jedes \(s\in S\) gilt.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Algebraische Signatur</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Eine <i>algebraische Signatur</i> besteht aus:
</p>

<ul class="org-ul">
<li>einer Menge von <i>Konstantensymbolen</i> \(C\)
</li>
<li>einer Menge von <i>Funktionssymbolen</i> \(F\)
</li>
<li>einem daraus gebildeten <i>Vokabular</i> \(V = C \dot{\cup} F\)
</li>
<li>einer Funktion \(\Sigma: V \rightarrow S^+ \cup (S^{*} \times S)\) mit den Eigenschaften
<ul class="org-ul">
<li>\(\Sigma(c) \in \{\epsilon\}\times S = \{\langle\rangle\} \times S\) für alle \(c \in C\)
</li>
<li>\(\Sigma(f) \in S^+\times S\) für alle \(f \in F\)
</li>
</ul>
</li>
</ul>

<p>
Ein Funktionswert \(\Sigma(v)\) heißt <i>Signatur von</i> \(v\). \(\Sigma\) heißt
<i>\(S\)-Signatur</i>.
</p>

<p>
Funktionssymbole schreiben wir mit kleinem Anfangsbuchstaben, z.B. \(d\)
für "decrypt".
</p>

<p>
Im einsortigen Fall deutet man die Signatur eines \(n\)-stelliges
Funktionssymbols verkürzt durch \(f//n\) an.
</p>

<p>
Eine Signatur kann man sich wie die Angabe eines "Interface"
vorstellen (vgl. z.B. die Syntax von <code>export</code> in Erlang oder Prolog)
</p>
</div>

<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> Terme</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Terme werden aus Variablen-, Konstanten- und Funktionssymbolen
zusammengesetzt und in einer Struktur unter einer Belegung
interpretiert.
</p>

<p>
Für jede Sorte \(s\in S\) mit \(M_s := \{x_0^s, x_1^s, \dots \}\)
definieren wir die Menge der \(s\)-\(\Sigma\)-Terme \(T_s(\Sigma)\)
induktiv:
</p>

<p>
<b>IA:</b>
</p>

<ul class="org-ul">
<li>für jedes \(i \in \mathbb{N}\) und \(s\in S\) gilt \(x_i^s \in
  T_s(\Sigma)\), d.h. \(x_i^s\) ist ein \(s\)-\(\Sigma\)-Term. Es gilt also \(M_s \subseteq T_s(\Sigma)\).
</li>
<li>für jedes \(c \in C\) mit \(\Sigma(c) = \langle
  \epsilon, s\rangle\) gilt \(c \in T_s(\Sigma)\), d.h. \(c\) ein \(s\)-\(\Sigma\)-Term.
</li>
</ul>

<p>
<b>IS:</b>
</p>

<p>
Ist \(f \in F\) bzw. \(f \in V\) mit \(\Sigma(f) = \langle s_0\dots s_m,
s\rangle\) und ist \(t_i \in T_{s_i}(\Sigma)\) für jedes \(i \leq m\) ein
\(s_i\)-\(\Sigma\)-Term, dann ist auch \(f(t_0,\dots,t_m) \in T_s(\Sigma)\)
ein \(s\)-\(\Sigma\)-Term.
</p>

<p>
Wir definieren die \(S\)-sortierte Menge \(T(\Sigma) := \{T_s(\Sigma)
\mid s \in S\}\). Die Elemente von \(T(\Sigma)\) heißen \(\Sigma\)-Terme.
</p>
</div>

<div id="outline-container-sec-1-4-1-1" class="outline-5">
<h5 id="sec-1-4-1-1"><span class="section-number-5">1.4.1.1</span> Semantik</h5>
<div class="outline-text-5" id="text-1-4-1-1">
<p>
Sei \(S\) eine Sortenmenge, \(\Sigma\) eine \(S\)-Signatur und \(\St\) eine
\(S\)-\(\Sigma\)-Struktur und sei \(\beta\) eine \(M\)-Belegung, die jeder
Variablen \(x_i^s\) ein Element aus \(s^{\St}\) zuordnet. Dann definieren
wir den Wert \(\llb t \rrb_{\beta}^{\St} \in s^{\St}\) eines
\(s\)-\(\Sigma\)-Terms \(t\) in der Struktur \(\St\) induktiv durch:
</p>

<p>
<b>IA:</b>
</p>

<ul class="org-ul">
<li>es gilt \(\llb x_i^s \rrb_{\beta}^{\St} = \beta(x_i^s)\) für alle \(i\in\mathbb{N}\) und \(s \in S\)
</li>
<li>es gilt \(\llb c \rrb_{\beta}^{\St} = c^{\St}\) für alle \(c\in C\)
</li>
</ul>

<p>
<b>IS:</b>
</p>

<p>
Es gilt \(\llb f(t_0,\dots,t_n)\rrb_{\beta}^{\St} = f^{\St}(\llb t_0
\rrb_{\beta}^{\St}, \dots, \llb t_n \rrb_{\beta}^{\St})\) für alle \(f
\in F\) mit \(\Sigma(f) = \langle s_0 \dots s_n,
s\rangle\) und alle \(t_i \in T_{s_i}(\Sigma)\) mit \(i\leq n\).
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> Gleichungen</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
Sei \(S\) eine Sortenmenge, \(\Sigma\) eine \(S\)-Signatur, dann ist eine
\(s\)-\(\Sigma\)-Gleichung ein Ausdruck der Form \(t \deq t'\) mit \(t,t' \in
T_s(\Sigma)\). Gleichungen können als Knoten-beschriftete Bäume
aufgefasst werden. Statt der Infix-Schreibweise \(t \deq t'\) verwenden
wir manchmal auch die Präfix-Schreibweise \(\deq(t,t')\).
</p>

<p>
Eine \(s\)-\(\Sigma\)-Gleichung \(t \deg t'\) gilt in einer Struktur \(\St\)
unter Belegung \(\beta\), wenn \(\llb t\rrb_{\beta}^{\St} = \llb
t'\rrb_{\beta}^{\St}\) gilt. Wir schreiben dann \(\St,\beta \models t
\deq t'\).
</p>

<p>
Eine \(s\)-\(\Sigma\)-Gleichung \(t \deg t'\) gilt in einer Struktur \(\St\),
wenn \(\llb t\rrb_{\beta}^{\St} = \llb t'\rrb_{\beta}^{\St}\) für alle
Belegungen \(\beta\) gilt. Wir schreiben dann \(\St \models_{eq} t \deq t'\).
</p>

<p>
Ist \(E\) eine Menge von \(s\)-\(\Sigma\)-Gleichungen, dann ist die Menge
aller Strukturen in denen die Gleichungen aus \(E\) gelten:
</p>

<p>
\(\Mod(E) := \{\St \mid \St \text{ ist } s\text{-}\Sigma\text{-Struktur mit } \St \models_{eq} e \text{ für alle } e\in E\}\)
</p>

<p>
\(\Mod(E)\) heißt auch die durch \(E\) <b>axiomatiserte Klasse</b> von
Strukturen.
</p>

<p>
Ist \(K\) eine Klasse von Strukturen, so heißt \(K\)
<b>gleichungsaxiomatisierbar</b>, falls es eine Menge \(E\) von
\(s\)-\(\Sigma\)-Gleichungen gibt, für die \(K=\Mod(E)\) gilt. Falls es eine
<i>endliche</i> Menge von Gleichungen gibt, die diese Bedingung erfüllt, dann
heißt die Klasse <b>endlich gleichungsaxiomatisierbar</b>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Relationale Signatur</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Eine <i>relationale Signatur</i> \(\mathscr{S}\) besteht aus:
</p>

<ul class="org-ul">
<li>einer Menge von <i>Konstantesymbolen</i> \(C\)
</li>
<li>einer Menge von <i>Relationssymbolen</i> \(R\)
</li>
<li>einem daraus gebildeten <i>Vokabular</i> \(V = C \dot{\cup} R\)
</li>
<li>einer Funktion \(\Sigma: V \rightarrow S^+ \cup (S^{*} \times S)\) mit den Eigenschaften
<ul class="org-ul">
<li>\(\Sigma(c) \in \{\epsilon\}\times S = \{\langle\rangle\} \times S\) für alle \(c \in C\)
</li>
<li>\(\Sigma(r) \in S^+\) für alle \(r \in R\)
</li>
</ul>
</li>
</ul>

<p>
Ein Funktionswert \(\Sigma(v)\) heißt <i>Signatur von</i> \(v\). \(\Sigma\) heißt
<i>Signatur</i>.
</p>

<p>
Relationssymbole schreiben wir mit kleinem Anfangsbuchstaben, z.B. \(e\)
für "edge".
</p>

<p>
Da sich \(V\) aus \(C\) und \(R\) ergibt, genügt es entweder \(V\) oder \(C\)
<i>und</i> \(R\) anzugeben. Welche Elemente aus \(V\) Konstanten sind und welche
Relationen erkennt man ggf. an der Signatur der Elemente, die
angegeben wird als \(\Sigma(v) = \dots\) für alle \(v\in V\).
</p>

<p>
Im einsortigen Fall deutet man die Signatur eines \(n\)-stelliges
Relationssymbols verkürzt durch \(r/n\) an.
</p>

<p>
Ist \(\Sigma\) eine relationale Struktur, dann sind \(\Sigma\)-Strukturen,
wie bei algebraischen Strukturen definiert mit dem Unterschied:
</p>

<ul class="org-ul">
<li>ist \(c \in C\), so gilt:
</li>
<li>ist \(r \in R\), so gilt: \(r^{\mathscr{S}} \subseteq s_0\times\dots\times S_{n}\) für \(f\) mit \(\Sigma(r) = s_{0}\dots s_n\)
</li>
</ul>
</div>

<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> Homomorphismus</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
Sei \(S\) eine Sortenmenge und \(\Sigma\) eine relationale \(S\)-Signatur.
</p>

<p>
Ein <b>Homomorphismus</b> ist eine Familie von Funktionen von einer
\(S\)-\(\Sigma\)-Struktur \(\St\) auf eine andere \(S\)-\(\Sigma\)-Struktur \(h:\St
\rightarrow \mathscr{T}\), d.h. für jede Sorte \(s \in S\) gibt es eine
Abbildung \(h_s: s^{\St}\rightarrow s^{\mathscr{T}}\).
</p>

<p>
Ein Homomorphismus muss folgende Eigenschaften erfüllen:
</p>

<ul class="org-ul">
<li>Für alle \(c\in C\) mit \(\Sigma(c) = \langle \epsilon, s\rangle\) gilt \(h_s(c^{\St}) = c^{\mathscr{T}}\).
</li>
<li>Für alle \(f \in F\) mit \(\Sigma(f) = \langle s_0 \dots s_n,
  s\rangle\) und alle \(a_0 \in s_0^{\St}, \dots, a_n \in s_n^{\St}\)
  gilt \(h_s(f^{\St}(a_0, \dots, a_n)) = f^{\mathscr{T}}(h_{s_0}(a_0),
  \dots, h_{s_n}(a_n))\)
</li>
<li>Für alle \(r \in R\) mit \(\Sigma(r) = s_0\dots s_n\) und alle \(a_0 \in
  s_0^{\St}, \dots, a_n \in s_n^{\St}\) gilt: Wenn \(\langle a_0, \dots,
  a_n \rangle \in r^{\St}\) gilt, dann gilt auch \(\langle h_{s_0}(a_0) \dots
  h_{s_n}(a_n)\rangle \in r^{\mathscr{T}}\)
</li>
</ul>

<p>
Wir schreiben auch \(r^{\St}(a_0, \dots, a_n)\) statt \(\langle a_0,
\dots, a_n \rangle \in r^{\St}\).
</p>

<p>
Wir bezeichnen die Menge der Homomorphismen von \(\St\) nach \(\mathscr{T}\) mit \(\homs(\St, \mathscr{T})\).
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Struktur</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Um Formeln interpretieren zu können muss jedem Bestandteil einer
Signatur eine Bedeutung gegeben werden. Dafür verwenden wir
Strukturen.
</p>

<p>
Sei \(\Sigma\) eine Signatur zu einer Sortenmenge \(S\). Dann ist eine
\(S\)-\(\Sigma\)-Struktur \(\mathscr{S}\) gegeben durch:
</p>

<ul class="org-ul">
<li>eine \(S\)-sortierte Menge \(M = \{M_s\}_{s\in S}\)
</li>
<li>für jedes \(c\in C\) mit \(\Sigma(c) = \langle \epsilon, s_0\rangle\)
  mit \(s_0\in S\) ein \(c^{\mathscr{S}}\) mit \(c^{\mathscr{S}} \in
  M_{s_0}\)
</li>
<li>für jedes Funktionssymbol \(f \in F\) mit \(\Sigma(f) = \langle
  s_0\dots s_n, s'\rangle\) mit \(s_0,\dots, s_n, s' \in S\) eine
Funktion \(f^{\mathscr{S}}: M_{s_0}\times \dots \times M_{s_n}
  \rightarrow M_{s'}\)
</li>
<li>für jedes Relationssymbol \(r \in R\) mit \(\Sigma(r) = s_0\dots s_n\)
  mit \(s_0,\dots, s_n \in S\) eine Relation \(r^{\mathscr{S}} \subseteq
  M_{s_0}\times \dots \times M_{s_n}\)
</li>
</ul>

<p>
\(d^{\St}\) kann man lesen als "schlage die Definition von \(d\) in der Struktur \(\mathscr{S}\) nach.
</p>

<p>
Die ne \(S\)-sortierte Menge \(M\) heißt auch <i>Trägermenge</i> der Struktur \(\St\).
</p>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> Formeln</h3>
<div class="outline-text-3" id="text-1-7">
<p>
<b>IA:</b> atomare Formeln:
</p>

<ul class="org-ul">
<li>\(\top,\bot\)
</li>
<li>Gleichungen \(t\deq t'\)
</li>
<li>Prädikatsfomrmeln \((t_0, \dots, t_n)\)
</li>
</ul>

<p>
<b>IS:</b> zusammengesetze Formeln
</p>

<ul class="org-ul">
<li>\(J(\varphi_0, \dots, \varphi_{n-1})\)
</li>
<li>\(\exists\: x_i^s \varphi\), \(\forall x_i^s \varphi\) mit Sorte \(s \in S\)
</li>
</ul>

<p>
Alternative: <i>Prädikatenlogik ohne Gleichheit</i>: Definiert wie oben, aber
Gleichungen sind nicht erlaubt.
</p>

<p>
Induktive Definition der Menge aller in einer Formel <i>frei</i> vorkommenden Variablen
</p>

<p>
<b>IA:</b> Basiszuordnung
</p>

<ul class="org-ul">
<li>\(\fvars(\bot} = \emptyset\)
</li>
<li>\(\fvars(\top} = \emptyset\)
</li>
<li>\(\fvars(t \deq t'} = \vars(t) \cup \vars(t')\) für \(t, t'\) \(\Sigma\)-Terme mit \(\vars(t)\) Menge der Variablen, die in \(t\) vorkommen f
</li>
<li>\(\fvars(r(t_0, \dots, t_n)} = \bigcup_{i \leq n} \vars(t_i)\)
</li>
</ul>

<p>
<b>IS:</b>
</p>

<ul class="org-ul">
<li>\(\fvars(J(\varphi_0, \dots, \varphi_{n-1})) = \bigcup_{i\leq n} \fvars(\varphi_i)\) für alle \(\varphi_i \in F_{PL}(\Sigma)\) mit \(i < n\) &#x2026;
</li>
<li>\(\fvars(\exists x_i^{s}\:\varphi) = \fvars(\varphi) \setminus \{x_i^s\}\)
</li>
<li>\(\fvars(\forall x_i^{s}\:\varphi) = \fvars(\varphi) \setminus \{x_i^s\}\)
</li>
</ul>
</div>

<div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1"><span class="section-number-4">1.7.1</span> <span class="todo TODO">TODO</span> Variablen spezifizieren</h4>
</div>

<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2"><span class="section-number-4">1.7.2</span> Koinzidenzlemma</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
Sei \(S\) eine Sortenmenge, \(\Sigma\) eine \(S\)-Signatur, \(\St\) eine
\(\Sigma\)-Struktur und seien \(\beta,\beta'\) \(\St\)-Belegungen mit
\(\beta|\fvars(\varphi) = \beta'|\fvars(\varphi)\) gilt: 
</p>

<p>
\(\llb \varphi\rrb_{\beta}^{\St} = \llb \varphi\rrb_{\beta'}^{\St}\)
</p>

<p>
Wir können also wieder mit partiellen Belegungen arbeiten.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> <span class="todo TODO">TODO</span> Anfrage</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Eine Anfrage ist ein Paar aus einer pädikatenlogischen Formel \(\varphi \in F_{PL}\) und einer Menge von Variablen:
</p>

<p>
\(\al \varphi, x_0 \ar^{\St} = \{ \al a \ar \mid a \in s^{\St} \wedge \St,\{x_0 \mapsto a \} \models \varphi\}\) definiert eine Relation.
</p>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> Substitution</h3>
<div class="outline-text-3" id="text-1-9">
</div><div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1"><span class="section-number-4">1.9.1</span> Ersetzung von</h4>
<div class="outline-text-4" id="text-1-9-1">
<ol class="org-ol">
<li>Substituion in der Ausagenlogik
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-9-2" class="outline-4">
<h4 id="sec-1-9-2"><span class="section-number-4">1.9.2</span> Termsubstitution</h4>
<div class="outline-text-4" id="text-1-9-2">
<p>
<i>(Term-)Substitution</i> ist das Ersetzen von freien Variablen durch Terme in einer PL-Formel \(\varphi\).
</p>

<p>
Eine Substitution ist eine Abbildung, die Variablen Terme derselben Sorte zuordnet.
</p>

<p>
Eine partielle Funktion \(\sigma: V_{FO} \rightarrow T(\Sigma)\) heißt
<b>Termsubstitution</b> (auch \(\Sigma\)-Substitution), falls für jedes \(i \in
\N\) und jedes \(s\in S\) mit \(x_i^s \in \def(\sigma)\) auch
\(\sigma(x_i^s) \in T_s(\Sigma)\) gilt. Wir definieren die Anwendung
einer Substitution induktiv durch:
</p>

<p>
<b>IA:</b>
</p>

<ul class="org-ul">
<li>\(c\sigma = c\) für alle \(c\in C\) und
</li>
</ul>

\begin{equation}
x_i^s\sigma = \begin{cases}
  \dots \\
\end{cases}
\end{equation}

<p>
<b>IS:</b>
</p>

<p>
ist \(f in F\) &#x2026; dann gilt 
</p>
</div>
</div>

<div id="outline-container-sec-1-9-3" class="outline-4">
<h4 id="sec-1-9-3"><span class="section-number-4">1.9.3</span> Termsubstitution auf Formeln</h4>
<div class="outline-text-4" id="text-1-9-3">
<p>
<b>IA:</b>
</p>

<ul class="org-ul">
<li>\(\top\sigma = \top\)
</li>
<li>\(\bot\sigma = \bot\)
</li>
<li>\((t \deq t')\sigma = t\sigma \deq t'\sigma\)
</li>
<li>\(r(t_0, \dots t_n)\sigma = r(t_0\sigma, \dots t_n\sigma)\)
</li>
</ul>

<p>
<b>IS:</b>
</p>

<ul class="org-ul">
<li>Sei \(J\) ein \(n\)-stelliger Junktor, dann gilt $J(&varphi;<sub>0</sub>, &hellip;, &varphi;<sub>n-1</sub>)&sigma;
</li>
</ul>

<p>
Wir definieren die Menge der Variablen, die im Wirkungsbereich einer Quantifizierung von \(x_i^s\) liegen durch \(\bvars_{x_i^s}\)
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> Quantoren</h3>
<div class="outline-text-3" id="text-1-10">
<p>
Für alle \(x_i^s \in V_s\) und \(\phi, \psi \in F_{PL}\)
</p>

<ul class="org-ul">
<li><b>Dualität</b> (Austauschen):
<ul class="org-ul">
<li>\(\neg\exists x_i^s \phi \equiv \forall x_i^s \neg \phi\)
</li>
<li>\(\neg\exists x_i^s \phi \equiv \forall x_i^s \neg \phi\)
</li>
</ul>
</li>
<li><b>Kommutativität</b> (Vertauschen):
<ul class="org-ul">
<li>\(\exists x_i^s \exists x_j^{s'} \phi \equiv \exists x_j^{s'} \exists x_i^s \phi\)
</li>
<li>\(\forall x_i^s \forall x_j^{s'} \phi \equiv \forall x_j^{s'} \forall x_i^s \phi\)
</li>
</ul>
</li>
<li><b>Distributivität</b> (Verteilen):
<ul class="org-ul">
<li>\(\exists x_i^s (\phi \vee \psi) \equiv \exists x_i^s \phi \vee \exists x_i^s \psi\)
</li>
<li>\(\forall x_i^s (\phi \wedge \psi) \equiv \forall x_i^s \phi \wedge \forall x_i^s \psi\)
</li>
</ul>
</li>
<li>(Eliminieren):
<ul class="org-ul">
<li>\(\exists x_i^s \phi \equiv \phi\) falls \(x_i^s \not\in \fvars(\phi)\)
</li>
<li>\(\forall x_i^s \phi \equiv \phi\) falls \(x_i^s \not\in \fvars(\phi)\)
</li>
</ul>
</li>
<li>(Verschieben):
<ul class="org-ul">
<li>\(\phi \wedge \exists x_i^s \psi \equiv \exists x_i^s (\phi \wedge \psi)\) falls \(x_i^s \not\in \fvars(\phi)\)
</li>
<li>\(\phi \vee \exists x_i^s \psi \equiv \exists x_i^s (\phi \vee \psi)\) falls \(x_i^s \not\in \fvars(\phi)\)
</li>
<li>\(\phi \wedge \forall x_i^s \psi \equiv \exists x_i^s (\phi \wedge \psi)\) falls \(x_i^s \not\in \fvars(\phi)\)
</li>
<li>&#x2026;
</li>
</ul>
</li>
<li>(Umbenennen):
<ul class="org-ul">
<li>\(\forall x_i^s \phi \equiv \forall x_i^s \phi\{x_i^s \mapsto x_j^s\}\) falls \(x_i^s \in \bvars_{x_j^s}(\phi)\) und \(x_j^s\not\in\fvars(\phi)\)
</li>
<li>&#x2026;
</li>
</ul>
</li>
<li>Einführen und Spezialisieren
<ul class="org-ul">
<li>\(\forall x_i^s \phi \VDash \phi\{x_i^s \mapsto t\}\), falls \(\{x_i^s \mapsto t\}\) zulässig bzgl. \(\phi\) und \(t\) ist \(s\)-Term
</li>
<li>\(\phi\{x_i^s \mapsto t\} \VDash \exists x_i\phi\{x_i^s \mapsto t\}\), falls \(\{x_i^s \mapsto t\}\) zulässig bzgl. \(\phi\) und \(t\) ist \(s\)-Term
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> <span class="todo TODO">TODO</span> Pränexe Normalform</h3>
<div class="outline-text-3" id="text-1-11">
<p>
Eine Formel \(\phi\) in <i>pränexer Normalform</i> kann man in der Form
</p>

<p>
\(\prefix(\phi) \kern(\phi)\)
</p>

<p>
schreiben, wobei \(\prefix(\phi)\) das <b>Quantorenpräfix</b> und \(\kern(\phi)\)
der <b>Kern</b> der Formel \(\phi\) sind.
</p>

<ol class="org-ol">
<li>Die Menge der \(\Sigma\)-Formeln in <i>pränexer Normalform</i> (PNF),
</li>
<li>der <b>Kern</b> \(\kern(\phi)\) einer Formel \(\phi\) in PNF,
</li>
<li>das <b>Quantorenpräfix</b> \(\prefix(\phi)\) einer Formel \(\phi\) in PNF und
</li>
<li>die <b>Menge der quantifizierten Variablen</b> \(\qvars(\phi)\) einer Formel \(\phi\) in PNF
</li>
</ol>

<p>
sind wie folgt induktiv definiert:
</p>

<p>
<b>IA:</b>
</p>

<p>
Jede quantorenfreie Formel \(\phi\) ist in PNF und es gilt:
</p>

<ul class="org-ul">
<li>\(\prefix(\phi) = \espilon\) 
</li>
<li>\(\kern(\phi) = \phi\) 
</li>
<li>\(\qvars(\phi) = \emptyset\)
</li>
</ul>

<p>
<b>IS:</b>
</p>

<p>
Ist \(\phi\) in PNF, \(Q \in \{\exists, \forall\}\), und sind \(i \in \N\)
und \(s \in S\), sodass \(x_i^s \in \fvars{\phi}\) gilt, dann ist auch \(Q
x_i^s \phi\) in PNF und es gilt:
</p>

<ul class="org-ul">
<li>\(\prefix(Qx_i^s \phi) = Q x_i^s \prefix(\phi)\)
</li>
<li>\(\kern(Qx_i^s \phi) = \kern(\phi)\)
</li>
<li>\(\qvars(Qx_i^s \phi) = \qvars(\phi) \cup \{x_i^s\}\)
</li>
</ul>

<p>
Tritt in dem Quantorenpräfix kein Existenzquantor auf, so spricht man
von einer <b>universellen Formel</b>. Besitzt eine universelle Formel keine
freien Variablen, so nennt man sie <b>universelle Aussage</b>.
</p>

<p>
<b>Eigenschaften:</b>
</p>

<ul class="org-ul">
<li>zu jeder prädikatenlogischen Formel gibt es eine äquivalente Formel in PNF.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12"><span class="section-number-3">1.12</span> <span class="todo TODO">TODO</span> Skolemisierung</h3>
<div class="outline-text-3" id="text-1-12">
<p>
Für Formeln, in denen keine freien Variablen auftreten.
</p>
</div>
</div>

<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13"><span class="section-number-3">1.13</span> <span class="todo TODO">TODO</span> Erfüllbarkeitsreduktion</h3>
<div class="outline-text-3" id="text-1-13">
<p>
Idee: Wenn wir ein Modell der ersten Formel haben, erhalten wir ein Modell der zweiten Formel wenn wir die 
</p>

<p>
Eine Formel \(\phi\) heißt erfüllbarkeitsreduzierbar auf eine Formel \(\psi\), wenn gilt
</p>

<ol class="org-ol">
<li>\(\fvars(\phi) = \fvars(\psi)\)
</li>
<li>Es gibt Signaturen \(\Sigma\) und \(\Sigma'\), mit \(\Sigma \subseteq
   \Sigma'\) und \(\phi \in F_{PL}(\Sigma)\) und \(\psi \in
   F_{PL}(\Sigma')\).
</li>
<li>Zu jeder \(\Sigma\)-Struktur \(\St\) gibt es eine \(\Sigma'\)-Expansion
\(\St'\) mit: für alle Belegungen \(\beta\) gilt: Wenn \(\St, \beta
   \models \phi\), dann gilt auch \(\St', \beta \models \psi\).
</li>
<li>Für jede \(\Sigma'\)-Struktur \(\St'\) und für jede Belegung \(\beta\)
gilt: Wenn \(\St, \beta \models \psi\), dann \(\St'|_{\Sigma}, \beta
   \models \phi\). Dabei heißt \(\St'|_{\Sigma}\) <i>Redukt</i> von \(\St'\), d.h.
wir "vergessen" die Symbole aus \(\Sigma'\setminus\Sigma\).
</li>
</ol>

<p>
Wir schreiben dann \(\phi \subsetsq \psi\).
</p>
</div>
</div>

<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14"><span class="section-number-3">1.14</span> <span class="todo TODO">TODO</span> Erfüllarkeitstests</h3>
</div>

<div id="outline-container-sec-1-15" class="outline-3">
<h3 id="sec-1-15"><span class="section-number-3">1.15</span> <span class="todo TODO">TODO</span> Termsturkuren und Modelle</h3>
<div class="outline-text-3" id="text-1-15">
<p>
Termsturkturen und Termmodelle entsprechen algebraischen Datentypen in
der Programmierung.
</p>
</div>
</div>

<div id="outline-container-sec-1-16" class="outline-3">
<h3 id="sec-1-16"><span class="section-number-3">1.16</span> Elimieren von Gleichheit</h3>
<div class="outline-text-3" id="text-1-16">
<p>
<i>Gleichheitsaxiome</i>:
</p>

<ul class="org-ul">
<li><i>Reflexivität</i>: \(\forall x_0 e(x_0,x_0)\)
</li>
<li><i>Symmetrie</i>: \(\forall x_0 \forall x_1 (e(x_0,x_1) \leftarrow e(x_1, x_0))\)
</li>
<li><i>Transitivität</i> \(\forall x_0 \forall x_1 \forall x_2 (e(x_0,x_1) \wedge e(x_1, x_2) \rightarrow e(x_0,x_2))\)
</li>
<li>\(\forall x_0 \dots \forall x_{2n-1} (e(x_0,x_1) \wedge e(x_2, x_3)
  \wedge \dots \wedge e(x_{2n-2}, x_{2n-1}) \rightarrow e(f(x_0, x_2,
  \dots, x_{2n-2}), f(x_1, x_3, \dots, x_{2n-1})))\) für \(f//n \in \Sigma\)
</li>
<li>&#x2026;
</li>
</ul>




<p>
Wir definieren die Relation $$
</p>
</div>
</div>
</div>
