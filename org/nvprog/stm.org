#+TITLE: Software Transactional Memory (STM)
#+STARTUP: content
#+STARTUP: latexpreview
#+STARTUP: inlineimages
#+OPTIONS: toc:nil
#+BEGIN_HTML
---
layout: page
title: Software Transactional Memory (STM)
---
#+END_HTML

* Locking Ansätze

- optimistische Ansatz: Vor dem Commit wird geprüft, ob die Transaktion noch valide ist.
- pessimistischer Ansatz: Ressourcen werden direkt gelockt

* STM

Ziel von Transaktionen:

- Deadlockfreiheit

Funktionsweise:

- Transaktionen werden auf einer lokaler Kopie der Daten ausgeführt.
- Dabei wird ein *readset* (RS) und eine *writeset* (WS) angelegt.
- Das readset enthält die Versionsnummer mit der die entsprechende
  Variable gelesen wurde.
- Bevor die Ergebnisse der Transaktion tatsächlich in die Daten
  übertragen werden (*commit*), werden RS und WS *validiert*, d.h. die
  gelesene Versionsnummern der Variablen werden mit den aktuellen
  Versionnummern der Variablen verglichen. Dazu müssen RS und WS
  gelockt werden.
- Vorzeitiges *rollback* kann sich ergeben, wenn eine Variable erneut
  mit anderer Versionsnummer gelesen wird.

Komposition von Transaktionen

- Sequentialisierung (=atomically=)
- orElse
  - wenn der zweite Fall in ein =retry= läuft, dann wird die gesamte
    Transaktion erneut durchgeführt
- Verzweigung (if ... else)
- Invarianten (=always=, =alwaysSucceed=)

*** TODO Wird die Versionsnummer auch im writeset protokolliert

Alternative Implementierung in =stm2.erl=

- =lock=-Nachricht muss dann auch durch den Hilfsprozess geschickt werden

** Retry

/busy waiting/ im =retry= kann verhindert werden durch: 

- readset locken 
- readset validieren (wenn nicht valide: rollback; wenn valide: bei
  TVars im Readset registrieren); readset danach jeweils unlocken
- suspendieren, bis eine Variable in meinem Readset verändert wird. 
- TVAR führt eine Liste mit, mit Prozessen, die auf diese TVar warten.
  Wenn write_tvar dieser TVar aufgerufen wird, werden alle wertenden
  Prozesse gweckt.

** Probleme von Transaktionen

Beispiel:

- TVars: =t1=, =t2=
- Invariante: alle Transaktionen sollen gewährleisten, dass der Inhalt
  von t1 und t2 identisch ist.

Betrachte folgede Transaktion:

#+BEGIN_EXAMPLE
    do
      v1 <- readTVar t1
      v2 <- readTVar t2
      if v1 /= v2 then loop
                  else return()

    loop = loop
#+END_EXAMPLE

Das Problem entsteht, wenn zwischen z.B. folgende Transaktion zwischen
den =readTVar= Aufrufen ausgeführt wird

#+BEGIN_EXAMPLE
    do
      writeTVar t1 42
      writeTVar t2 42
#+END_EXAMPLE

Das die Transkation mit den readTVars dann invalid ist, kann erst am
Ende der Transaktion erkannt werden (beim Validieren). Da das Programm
aber in eine Endlosschleife läuft, kann das nicht passieren.

Bei GHC ist das unkritisch, da dieser =loop= als Endlosschleife erkennen
würde.

** Invarianten

Implementierung von Invarianten in Haskell =STM=

#+BEGIN_EXAMPLE
    alwaysSucceeds (do
      v1 <- readTVar t1
      v2 <- readTVar t2
      if v1 /= v2 then retry
                  else return ()
#+END_EXAMPLE

Jede Transaktion wird nur dann commited, wenn die Transaktion von
=alwaysSucceeds= erfolgreich ist.

Eine Invarianten sollten keine TVars schreiben, da im Allgmeinen nicht
klar ist, was dann geschehen soll. Das könnte man natürlich konkreteiseren, aber GHC tut dies z.B. nicht.

#+BEGIN_EXAMPLE
    always (do
      v1 <- readTVar t1
      v2 <- readTVar t2
      return (v1 /= v2))
#+END_EXAMPLE

Überprüfung von Invarianten:

-  überprüfe alle Invarianten am Ende jeder Transaktion auf Zustand,
   welcher *nach* dem commit vorliegt. D.h. das /write set/ der
   aktuellen Transaktion muss der Überprüfung der Invarianten mit
   übergeben werden. Eigentlich nicht alle, sondern nur die, die
   Invarianten, deren letztes RS betroffen ist (bei jeder Überprüfung
   der Invariante kann sich ein anderes Readset ergeben.

=always= und =alwaysSucceeds= prüfen die übergeben Invariante sofort,
wenn diese Validierung fehl schlägt, dann wird die Invariante nicht
übernommen, ansonsten wird sie übernommen und muss von da an am Ende
jeder nachfolgenden Transaktion gelten. Insbesondere auch am Ende der
Transaktion, in der die Invariante etabliert wird. Gilt die Invariante
nicht am Ende der aktuellen Transaktion, dann wird die Invariante auch
nicht übernommen.

#+BEGIN_EXAMPLE
    install = do
      writeTVar t1 42
      writeTVar t2 42
      -- invariante
#+END_EXAMPLE

Invarianten können nicht wieder zurück genommen werden.

Invarianten unterstützen kompositionelles Arbeiten, da sich andere
Transaktionen nicht mehr um die Erfüllung dieser Invarianten kümmern
müssen. Hier entsteht aber ein Trade-off zwischen Programmierarbeit und
Performanz.

** Grenzen von Transaktionen

-  die Wahrscheinlichkeit eines rollbacks steigt mit der Länge der
   Transaktion. Sehr lange Transkationen können dadurch zu einem
   livelock führen.

   -  Bestimmte Datenstrukturen, z.B. verkettete Listen sind
      problematisch für die Verwendung in Transaktionen, da beim
      Durchlaufen der Liste viele Elemente gelesen werden




** TODO Transaktinsbasierten Channel zu einer Queue umwandeln können

** TODO Idee der zweiten Version der STM implementierung erklären können

** TODO erkären, wie retry ohne busy waiting möglich ist

** TODO pessimistische Implementierung von STM in Erlang (siehe Übung)

** TODO Web-Anwendungen von STM
