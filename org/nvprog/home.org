#+TITLE: Nebenläufige und verteilte Programmierung
#+STARTUP: content
#+STARTUP: latexpreview
#+STARTUP: inlineimages
#+OPTIONS: toc:nil

* Inhalt

- Interprozesskommunikation (auf geteiltem Speicher)
  - Semaphoren
  - Monitore
	- [[../os/monitors][Allgemeines zum Monitorkonzept]]
	- [[../lang/java.org][Das Monitorkonzept in Java]]
- MVar
  - 
- [[./linda.org][Linda-Modell]]
- [[./ltl.org][LTL]]

* Begriffe

*Nebenläufigkeit*: Nebenläufigkeit verwenden wir als Überbegriff für

- Nebenläufigkeit (Scheduling von Prozessen) auf einem Prozessorkern und
- echter Parallelität (auf Mehrkernprozessoren)

mit der Zielsetzung:

- Performanzsteigerung und
- hohe Reaktivität des Systems zu gewährleisten.

*Verteilte Systeme:* Verteilte Systeme haben i.d.R. nicht das Ziel der
Performanzsteigerung. Meist haben die Systeme auf natürliche Weise
verteilten Charakter (z.B. Mobiltelefone)

*Deadlock*:

* Semaphore

#+BEGIN_EXAMPLE
    i = 0;
    sem = 1;

    p(sem);
    {i = i+1;} || {i=2*i}
    v(sem);

    puts(i);
#+END_EXAMPLE

Beispiele:

-  Buffer
-  Producer-Consumer Problem
-  Dining Philosophers

*Schwachstellen von Semaphoren:*

-  p() und v() müssen explizit gesetzt werden. Dabei können Fehler
   passieren.
-  kein reentry: Man muss immer sicherstellen, dass zur Laufzeit nicht
   zweimal hintereinander (z.B. in unterschiedlichen Methoden) =p()=
   aufgerufen wird
-  syntaktisch unschön: atomare Blöcke im Code schwer zu identifizieren;
   der code wird schnell unübersichtlich

* Monitore

[[../os/monitors][Allgemeines zum Monitorkonzept]]

[[../lang/java.org][Das Monitorkonzept in Java]]

Implementierungen:

- Philosophen
- MVar

* Datenstrukturen
** MVar

zentrale Operationen

- =take=
- =put=
- =read=
- =trytake=
- ...

** Channel

Unterschied zwischen Mailbox eines Prozesses in Erlang und eines
Channel:

*** TODO isEmpty bug erklären können


** TODO Aufbau

zentrale Operationen:

- =read=
- =write=
- =isEmpty=
  - sicherer, wenn Füllstand über einen Semaphore erfasst wird

* Erlang

Implementierungen

- MVar
- Semaphore
- Philosophen

** TODO Wofür Prozesse registrieren und welche?

** TODO Wie robust in Erlang programmieren?

- linking von Prozessen
- implementiert über Poll-Nachrichten für remote Knoten
- lokale Prozesse die sterben benachrichtigen ihre verlinkten Prozesse

** TODO Sematik von =receive= verstehen. Erklären anhand eines kleines Beispielprogramms

* Andere Probleme

** Dining Philosophers

[[../os/dining_philosophers_problem][Das Dining Philosopher Problem]]

** Chat

Probleme im verteilten Chat erklären können.


*** TODO Wo findet die Prüfung am 21.07. statt?
* Algorithmen für Parallelisierung von Problemen

Probleme bei der Aufteilung von Problemen:

- rekursive Algorithmen sind problematisch, da i.d.R. erst zur
  Laufzeit bekannt ist, in wie viele Teilprobleme ein Problem
  aufzuteilen wird
- Teilprobleme können unterschiedlich aufwendig sein
  - Mögliche Lösungen
	- Probleme zur Laufzeit verteilen (festlegen eines *Hypervisors*, der
      ausschlißlich das Verteilen der Teilprobleme auf die übrigen
      Knoten übernimmt)
	- Knoten warten aufeinander
	- Jobs werden in einer Kette weitergeschickt, d.h. jeder Knoten
      kennt seinen Nachfolger und schickt Probleme, die er selbst
      nicht bearbeiten kann an seinen Nachfolger weiter
	  - Problem: im schlimmsten Fall wird der Job immer bis zum
        letzten Knoten durchgereicht
