
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Organisatorisches</h2>
<div class="outline-text-2" id="text-1">
<p>
In der ersten Woche noch keine Übung
</p>

<p>
Prüfung
</p>

<ul class="org-ul">
<li>Termine: 1. PZ, Sep, Okt
</li>
<li>mündliche Prüfung (2 Personen: 40 Min., 1 Person: ?)
</li>
<li>Prüfungsinhalte: schriflich Programmieren, Konzepte der VL sollen
verstanden sein und präzise beschrieben werden können.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Begriffe</h2>
<div class="outline-text-2" id="text-2">
<p>
<b>Nebenläufigkeit</b> verwenden wir als Überbegriff für Nebenläufigkeit
(Scheduling von Prozessen auf einem Prozessorkern) und echter
Prallelität (auf Mehrkernprozessoren).
</p>

<p>
Ziel der Nebenläufigkeit:
</p>

<ul class="org-ul">
<li>i.d.R. Performanzsteigerung
</li>
<li>hohe Reaktivität des Systems gewährleisten
</li>
</ul>

<p>
<b>Verteilte Systeme:</b> Verteilte Systeme haben i.d.R. nicht das Ziel der
Performanzsteigerung. Meist haben die Systeme auf natürliche Weise
verteilten Charakter (z.B. Mobiltelefone)
</p>

<p>
<b>Deadlock</b>:
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Semaphore</h2>
<div class="outline-text-2" id="text-3">
<pre class="example">
i = 0;
sem = 1;

p(sem);
{i = i+1;} || {i=2*i}
v(sem);

puts(i);
</pre>

<p>
Beispiele:
</p>

<ul class="org-ul">
<li>Buffer
</li>
<li>Producer-Consumer Problem
</li>
<li>Dining Philosophers
</li>
</ul>

<p>
<b>Schwachstellen von Semaphoren:</b>
</p>

<ul class="org-ul">
<li>p() und v() müssen explizit gesetzt werden. Dabei können Fehler
passieren.
</li>
<li>kein reentry: Man muss immer sicherstellen, dass zur Laufzeit nicht
zweimal hintereinander (z.B. in unterschiedlichen Methoden) <code>p()</code>
aufgerufen wird
</li>
<li>syntaktisch unschön: atomare Blöcke im Code schwer zu identifizieren;
der code wird schnell unübersichtlich
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Monitore</h2>
<div class="outline-text-2" id="text-4">
<p>
<a href="../os/monitors">Allgemeines zum Monitorkonzept</a>
</p>

<p>
<a href="../lang/java">Das Monitorkonzept in Java</a>
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Dining Philosophers</h2>
<div class="outline-text-2" id="text-5">
<p>
<a href="../os/dining_philosophers_problem">Das Dining Philosopher Problem</a>
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Linda-Modell</h2>
<div class="outline-text-2" id="text-6">
<p>
Tupelspace
</p>

<p>
Operationen:
</p>

<ul class="org-ul">
<li><code>in</code>
</li>
<li><code>out</code>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Transaktionen</h2>
<div class="outline-text-2" id="text-7">
<p>
Ziel von Transaktionen:
</p>

<ul class="org-ul">
<li>Deadlockfreiheit
</li>
</ul>

<p>
Funktionsweise:
</p>

<ul class="org-ul">
<li>Transaktionen werden auf einer lokaler Kopie der Daten ausgeführt.
</li>
<li>Dabei wird ein <b>readset</b> (RS) und eine <b>writeset</b> (WS) angelegt.
</li>
<li>Das readset enthält die Versionsnummer mit der die entsprechende
Variable gelesen wurde.
</li>
<li>Bevor die Ergebnisse der Transaktion tatsächlich in die Daten
übertragen werden (<b>commit</b>), werden RS und WS <b>validiert</b>, d.h. die
gelesene Versionsnummern der Variablen werden mit den aktuellen
Versionnummern der Variablen verglichen. Dazu müssen RS und WS
gelockt werden.
</li>
<li>Vorzeitiges <b>rollback</b> kann sich ergeben, wenn eine Variable erneut
mit anderer Versionsnummer gelesen wird.
</li>
</ul>

<p>
Komposition von Transaktionen
</p>

<ul class="org-ul">
<li>Sequentialisierung (<code>atomically</code>)
</li>
<li>orElse
</li>
<li>Invarianten (<code>always</code>, <code>alwaysSucceed</code>)
</li>
</ul>
</div>

<div id="outline-container-sec-7-0-1" class="outline-4">
<h4 id="sec-7-0-1"><span class="section-number-4">7.0.1</span> <span class="todo TODO">TODO</span> Wird die Versionsnummer auch im writeset protokolliert</h4>
<div class="outline-text-4" id="text-7-0-1">
<p>
Alternative Implementierung in <code>stm2.erl</code>
</p>

<ul class="org-ul">
<li><code>lock</code>-Nachricht muss dann auch durch den Hilfsprozess geschickt werden
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> Retry</h3>
<div class="outline-text-3" id="text-7-1">
<p>
<i>busy waiting</i> im <code>retry</code> kann verhindert werden durch: 
</p>

<ul class="org-ul">
<li>readset locken 
</li>
<li>readset validieren (wenn nicht valide: rollback; wenn valide: bei
TVars im Readset registrieren); readset danach jeweils unlocken
</li>
<li>suspendieren, bis eine Variable in meinem Readset verändert wird. 
</li>
<li>TVAR führt eine Liste mit, mit Prozessen, die auf diese TVar warten.
Wenn write<sub>tvar</sub> dieser TVar aufgerufen wird, werden alle wertenden
Prozesse gweckt.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Probleme von Transaktionen</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Beispiel:
</p>

<ul class="org-ul">
<li>TVars: <code>t1</code>, <code>t2</code>
</li>
<li>Invariante: alle Transaktionen sollen gewährleisten, dass der Inhalt
von t1 und t2 identisch ist.
</li>
</ul>

<p>
Betrachte folgede Transaktion:
</p>

<pre class="example">
do
  v1 &lt;- readTVar t1
  v2 &lt;- readTVar t2
  if v1 /= v2 then loop
              else return()

loop = loop
</pre>

<p>
Das Problem entsteht, wenn zwischen z.B. folgende Transaktion zwischen
den <code>readTVar</code> Aufrufen ausgeführt wird
</p>

<pre class="example">
do
  writeTVar t1 42
  writeTVar t2 42
</pre>

<p>
Das die Transkation mit den readTVars dann invalid ist, kann erst am
Ende der Transaktion erkannt werden (beim Validieren). Da das Programm
aber in eine Endlosschleife läuft, kann das nicht passieren.
</p>

<p>
Bei GHC ist das unkritisch, da dieser <code>loop</code> als Endlosschleife erkennen
würde.
</p>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> Invarianten</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Implementierung von Invarianten in Haskell <code>STM</code>
</p>

<pre class="example">
alwaysSucceeds (do
  v1 &lt;- readTVar t1
  v2 &lt;- readTVar t2
  if v1 /= v2 then retry
              else return ()
</pre>

<p>
Jede Transaktion wird nur dann commited, wenn die Transaktion von
<code>alwaysSucceeds</code> erfolgreich ist.
</p>

<p>
Eine Invarianten sollten keine TVars schreiben, da im Allgmeinen nicht
klar ist, was dann geschehen soll. Das könnte man natürlich konkreteiseren, aber GHC tut dies z.B. nicht.
</p>

<pre class="example">
always (do
  v1 &lt;- readTVar t1
  v2 &lt;- readTVar t2
  return (v1 /= v2))
</pre>

<p>
Überprüfung von Invarianten:
</p>

<ul class="org-ul">
<li>überprüfe alle Invarianten am Ende jeder Transaktion auf Zustand,
welcher <b>nach</b> dem commit vorliegt. D.h. das <i>write set</i> der
aktuellen Transaktion muss der Überprüfung der Invarianten mit
übergeben werden. Eigentlich nicht alle, sondern nur die, die
Invarianten, deren letztes RS betroffen ist (bei jeder Überprüfung
der Invariante kann sich ein anderes Readset ergeben.
</li>
</ul>

<p>
<code>always</code> und <code>alwaysSucceeds</code> prüfen die übergeben Invariante sofort,
wenn diese Validierung fehl schlägt, dann wird die Invariante nicht
übernommen, ansonsten wird sie übernommen und muss von da an am Ende
jeder nachfolgenden Transaktion gelten. Insbesondere auch am Ende der
Transaktion, in der die Invariante etabliert wird. Gilt die Invariante
nicht am Ende der aktuellen Transaktion, dann wird die Invariante auch
nicht übernommen.
</p>

<pre class="example">
install = do
  writeTVar t1 42
  writeTVar t2 42
  -- invariante
</pre>

<p>
Invarianten können nicht wieder zurück genommen werden.
</p>

<p>
Invarianten unterstützen kompositionelles Arbeiten, da sich andere
Transaktionen nicht mehr um die Erfüllung dieser Invarianten kümmern
müssen. Hier entsteht aber ein Trade-off zwischen Programmierarbeit und
Performanz.
</p>
</div>
</div>

<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> Grenzen von Transaktionen</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li>die Wahrscheinlichkeit eines rollbacks steigt mit der Länge der
Transaktion. Sehr lange Transkationen können dadurch zu einem
livelock führen.

<ul class="org-ul">
<li>Bestimmte Datenstrukturen, z.B. verkettete Listen sind
problematisch für die Verwendung in Transaktionen, da beim
Durchlaufen der Liste viele Elemente gelesen werden
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
